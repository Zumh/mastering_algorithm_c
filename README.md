# mastering_algorithm_c

## Data Structures
5. Linked Lists
5.1. Description of Linked Lists
5.2. Interface for Linked Lists
5.3. Implementation and Analysis of Linked Lists
5.3.1. list_init
5.3.2. list_destroy
5.3.3. list_ins_next
5.3.4. list_rem_next
5.3.5. list_size, list_head, list_tail, list_is_tail,list_data, and list_next
5.4. Linked List Example: Frame Management
5.5. Description of Doubly-Linked Lists
5.6. Interface for Doubly-Linked Lists
5.7. Implementation and Analysis of Doubly Linked Lists
5.7.1. dlist_init
5.7.2. dlist_destroy
5.7.3. dlist_ins_next
5.7.4. dlist_ins_ prev
5.7.5. dlist_remove
5.7.6. dlist_size, dlist_head, dlist_tail, dlist_is_head, dlist_is_tail, dlist_data, dlist_next, and dlist_ prev
5.8. Description of Circular Lists
5.9. Interface for Circular Lists
5.10. Implementation and Analysis of Circular Lists
5.10.1. clist_init
5.10.2. clist_destroy
5.10.3. clist_ins_next
5.10.4. clist_rem_next
5.10.5. clist_size, clist_head, clist_data, and clist_next
5.11. Circular List Example: Second-Chance Page Replacement
5.12. Questions and Answers
5.13. Related Topics
6. Stacks and Queues
6.1. Description of Stacks
6.2. Interface for Stacks
6.3. Implementation and Analysis of Stacks
6.3.1. stack_init
6.3.2. stack_destroy
6.3.3. stack_ push
6.3.4. stack_ pop
6.3.5. stack_ peek, stack_size
6.4. Description of Queues
6.5. Interface for Queues
6.6. Implementation and Analysis of Queues
6.6.1. queue_init
6.6.2. queue_destroy
6.6.3. queue_enqueue
6.6.4. queue_dequeue
6.6.5. queue_ peek, queue_size
6.7. Queue Example: Event Handling
6.8. Questions and Answers
6.9. Related Topics
7. Sets
7.1. Description of Sets
7.1.1. Definitions
7.1.2. Basic Operations
7.1.3. Properties
7.2. Interface for Sets
7.3. Implementation and Analysis of Sets
7.3.1. set_init
7.3.2. set_destroy
7.3.3. set_insert
7.3.4. set_remove
7.3.5. set_union
7.3.6. set_intersection
7.3.7. set_difference
7.3.8. set_is_member
7.3.9. set_is_subset
7.3.10. set_is_equal
7.3.11. set_size
7.4. Set Example: Set Covering
7.5. Questions and Answers
7.6. Related Topics
8. Hash Tables
8.1. Description of Chained Hash Tables
8.1.1. Collision Resolution
8.1.2. Selecting a Hash Function
8.1.2.1. Division method
8.1.2.2. Multiplication method
8.2. Interface for Chained Hash Tables
8.3. Implementation and Analysis of Chained Hash Tables
8.3.1. chtbl_init
8.3.2. chtbl_destroy
8.3.3. chtbl_insert
8.3.4. chtbl_remove
8.3.5. chtbl_lookup
8.3.6. chtbl_size
8.4. Chained Hash Table Example: Symbol Tables
8.5. Description of Open-Addressed Hash Tables
8.5.1. Collision Resolution
8.5.1.1. Linear probing
8.5.1.2. Double hashing
8.6. Interface for Open-Addressed Hash Tables
8.7. Implementation and Analysisof Open Addressed Hash Tables
8.7.1. ohtbl_init
8.7.2. ohtbl_destroy
8.7.3. ohtbl_insert
8.7.4. ohtbl_remove
8.7.5. ohtbl_lookup
8.7.6. ohtbl_size
8.8. Questions and Answers
8.9. Related Topics
9. Trees
9.1. Description of Binary Trees
9.1.1. Traversal Methods
9.1.1.1. Preorder traversal
9.1.1.2. Inorder traversal
9.1.1.3. Postorder traversal
9.1.1.4. Level-order traversal
9.1.2. Tree Balancing
9.2. Interface for Binary Trees
9.3. Implementation and Analysis of Binary Trees
9.3.1. bitree_init
9.3.2. bitree_destroy
9.3.3. bitree_ins_left
9.3.4. bitree_ins_right
9.3.5. bitree_rem_left
9.3.6. bitree_rem_right
9.3.7. bitree_merge
9.3.8. bitree_size, bitree_root, bitree_is_eob, bitree_is_leaf, bitree_data, bitree_left, bitree_right
9.4. Binary Tree Example: Expression Processing
9.5. Description of Binary Search Trees
9.6. Interface for Binary Search Trees
9.7. Implementation and Analysis of Binary Search Trees
9.7.1. Rotations in AVL Trees
9.7.1.1. LL rotation
9.7.1.2. LR rotation
9.7.1.3. RR rotation
9.7.1.4. RL rotation
9.7.2. bistree_init
9.7.3. bistree_destroy
9.7.4. bistree_insert
9.7.5. bistree_remove
9.7.6. bistree_lookup
9.7.7. bistree_size
9.8. Questions and Answers
9.9. Related Topics
10. Heaps and Priority Queues
10.1. Description of Heaps
10.2. Interface for Heaps
10.3. Implementation and Analysis of Heaps
10.3.1. heap_init
10.3.2. heap_destroy
10.3.3. heap_insert
10.3.4. heap_extract
10.3.5. heap_size
10.4. Description of Priority Queues
10.5. Interface for Priority Queues
10.6. Implementation and Analysis of Priority Queues
10.7. Priority Queue Example: Parcel Sorting
10.8. Questions and Answers
10.9. Related Topics
11. Graphs
11.1. Description of Graphs
11.1.1. Search Methods
11.1.1.1. Breadth-first search
11.1.1.2. Depth-first search
11.2. Interface for Graphs
11.3. Implementation and Analysis of Graphs
11.3.1. graph_init
11.3.2. graph_destroy
11.3.3. graph_ins_vertex
11.3.4. graph_ins_edge
11.3.5. graph_rem_vertex
11.3.6. graph_rem_edge
11.3.7. graph_adjlist
11.3.8. graph_is_adjacent
11.3.9. graph_adjlists, graph_vcount, graph_ecount
11.4. Graph Example: Counting Network Hops
11.5. Graph Example: Topological Sorting
